// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "brevis-contracts/contracts/sdk/apps/framework/BrevisApp.sol";
import "brevis-contracts/contracts/sdk/interface/IBrevisProof.sol";

interface IAccountModule {
    function getAccountOwner(uint128 accountId) external view returns (address);
}

struct ClaimedPeriod {
    uint64 startBlockNumber;
    uint64 endBlockNumber;     
}

contract FeeReimbursementApp is BrevisApp, Ownable {
    using SafeERC20 for IERC20;

    address public rewardToken;
    uint24 public rewardTokenDecimals;
    IAccountModule public accountModule;
    mapping(bytes32 => uint16) public vkHashesToCircuitSize; // batch tier vk hashes => tier batch size
    mapping(uint128 => ClaimedPeriod) public accountIdClaimedPeriod;
    event FeeReimbursed(address indexed user, uint128 accountId, uint248 feeRebate, uint32 startYearMonthDay, uint32 endYearMonthDay, uint64 startBlockNumber,uint64 endBlockNumber);
    event VkHashesUpdated(bytes32[] vkHashes, uint16[] sizes);

    constructor(address _brevisProof) BrevisApp(IBrevisProof(_brevisProof)) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying keys. This proves that the _circuitOutput is authentic
        uint16 circuitSize = vkHashesToCircuitSize[_vkHash];
        require(circuitSize > 0, "vkHash not valid");

        (uint32 startYMD, uint32 endYMD, uint128 accountId, uint248 volume, uint248 fee, uint64 startBlockNumber, uint64 endBlockNumber) = decodeOutput(_circuitOutput);
        require(_validClaimPeriod(startBlockNumber, accountId), "invalid claim period");

        uint248 feeRebate;
        if (volume > 100000000 * 1e18) {
            feeRebate = fee * 90 / 100;
        } else if (volume > 10000000 * 1e18) {
            feeRebate = fee * 75 / 100;
        } else if (volume > 1000000 * 1e18) {
            feeRebate = fee * 50 / 100;
        } else if (volume > 100000 * 1e18) {
            feeRebate = fee * 20 / 100;
        }

        address user;
        if (feeRebate > 0) {
            user = accountModule.getAccountOwner(accountId);
            if (user != address(0)) {
                uint256 feeInRewardToken = feeRebate * (10 ** rewardTokenDecimals) / 1e18;
                IERC20(rewardToken).safeTransfer(user, feeInRewardToken);
            }
        }

        ClaimedPeriod memory claimedPeriod = accountIdClaimedPeriod[accountId];
        if (claimedPeriod.startBlockNumber == 0) {
            claimedPeriod.startBlockNumber = startBlockNumber;
        }
        claimedPeriod.endBlockNumber = endBlockNumber;
        accountIdClaimedPeriod[accountId] = claimedPeriod;

        emit FeeReimbursed(user, accountId, feeRebate, startYMD, endYMD, startBlockNumber, endBlockNumber);
    }

    function decodeOutput(bytes calldata o) internal pure returns (uint32 startYMD, uint32 endYMD, uint128 accountId, uint248 volume, uint248 fee, uint64 startBlockNumber,uint64 endBlockNumber) {
        startYMD = uint32(bytes4(o[0:4])); // start date: 20240405
        endYMD = uint32(bytes4(o[4:8])); // end data: 20240503
        accountId = uint128(bytes16(o[8:24]));
        volume = uint248(bytes31(o[24:55]));
        fee = uint248(bytes31(o[55:86]));
        startBlockNumber = uint64(bytes8(o[86:94]));
        endBlockNumber = uint64(bytes8(o[94:102]));
    }


    function _validClaimPeriod(uint64 startBlockNumber, uint128 accountId) internal view returns (bool) {
        ClaimedPeriod memory claimedPeriod = accountIdClaimedPeriod[accountId];
        if (claimedPeriod.startBlockNumber == 0 && claimedPeriod.endBlockNumber == 0) {
            return true;
        }
        if (startBlockNumber <= claimedPeriod.endBlockNumber) {
            return false;
        }

        return true;
    }

    function setVkHashes(bytes32[] calldata _vkHashes, uint16[] calldata _sizes) public onlyOwner {
        require(_vkHashes.length == _sizes.length, "length not match");
        for (uint256 i = 0; i < _vkHashes.length; i++) {
            vkHashesToCircuitSize[_vkHashes[i]] = _sizes[i];
        }

        emit VkHashesUpdated(_vkHashes, _sizes);
    }

    function setRewardToken(address _rewardToken, uint24 _decimals) external onlyOwner {
        rewardToken = _rewardToken;
        rewardTokenDecimals = _decimals;
    }

    function setAccountModule(IAccountModule _accountModule) external onlyOwner {
        accountModule = _accountModule;
    }
}
