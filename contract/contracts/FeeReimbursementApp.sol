// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "brevis-contracts/contracts/sdk/apps/framework/BrevisApp.sol";
import "brevis-contracts/contracts/sdk/interface/IBrevisProof.sol";


contract FeeReimbursementApp is BrevisApp, Ownable {
    using SafeERC20 for IERC20;
    
    bytes32 public vkHash;
    event FeeReimbursed(address indexed user, uint24 tradeYearMonth, uint256 fee);

    constructor(address _brevisProof) BrevisApp(IBrevisProof(_brevisProof)) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying key. This proves that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");

        (address user, uint24 tradeYearMonth, uint256 fee) = decodeOutput(_circuitOutput);
        emit FeeReimbursed(user, tradeYearMonth, fee);
    }

    function decodeOutput(bytes calldata o) internal pure returns (address, uint24, uint256) {
        address user = address(bytes20(o[0:20]));
        uint24 tradeYearMonth = uint24(bytes3(o[20:23])); 
        uint256 fee = uint256(uint248(bytes31(o[23:54]))); 
        return (user, tradeYearMonth, fee);
    }

    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }
}
