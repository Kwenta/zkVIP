// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "brevis-contracts/contracts/sdk/apps/framework/BrevisApp.sol";
import "brevis-contracts/contracts/sdk/interface/IBrevisProof.sol";

interface IAccountModule {
    function getAccountOwner(uint128 accountId) external view returns (address);
}

struct ClaimedPeriod {
    uint64 startBlockNumber;
    uint64 endBlockNumber;     
}

error InvalidNewClaimPeriod();

contract FeeReimbursementApp is BrevisApp, Ownable {
    using SafeERC20 for IERC20;

    address public rewardToken;
    uint24 public rewardTokenDecimals;
    IAccountModule public accountModule;
    mapping(bytes32 => uint16) public vkHashesToCircuitSize; // batch tier vk hashes => tier batch size
    mapping(uint128 => ClaimedPeriod) public accountIdClaimedPeriod;
    event FeeReimbursed(address indexed user, uint128 accountId, uint248 feeRebate, uint64 startBlockNumber,uint64 endBlockNumber);
    event VkHashesUpdated(bytes32[] vkHashes, uint16[] sizes);

    constructor(address _brevisProof) BrevisApp(IBrevisProof(_brevisProof)) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    function handleProofResult(
        bytes32 /*_requestId*/,
        bytes32 _vkHash,
        bytes calldata _circuitOutput
    ) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof generated by our circuit is indeed
        // our designated verifying keys. This proves that the _circuitOutput is authentic
        uint16 circuitSize = vkHashesToCircuitSize[_vkHash];
        require(circuitSize > 0, "vkHash not valid");

        (uint128 accountId, uint248 feeRebate, uint64 startBlockNumber, uint64 endBlockNumber) = decodeOutput(_circuitOutput);
        ClaimedPeriod memory claimedPeriod = _newClaimPeriod(startBlockNumber, endBlockNumber, accountId);
        address user;
        if (feeRebate > 0) {
            user = accountModule.getAccountOwner(accountId);
            if (user != address(0)) {
                uint256 feeInRewardToken = feeRebate * (10 ** rewardTokenDecimals) / 1e18;
                IERC20(rewardToken).safeTransfer(user, feeInRewardToken);
            }
        }

        accountIdClaimedPeriod[accountId] = claimedPeriod;
        emit FeeReimbursed(user, accountId, feeRebate, startBlockNumber, endBlockNumber);
    }

    function decodeOutput(bytes calldata o) internal pure returns (uint128 accountId, uint248 feeRebate, uint64 startBlockNumber,uint64 endBlockNumber) {
        accountId = uint128(bytes16(o[0:16]));
        feeRebate = uint248(bytes31(o[16:47]));
        startBlockNumber = uint64(bytes8(o[47:55]));
        endBlockNumber = uint64(bytes8(o[55:63]));
    }


    function _newClaimPeriod(uint64 startBlockNumber, uint64 endBlockNumber, uint128 accountId) internal view returns (ClaimedPeriod memory) {
        ClaimedPeriod memory claimedPeriod = accountIdClaimedPeriod[accountId];
        // No claim record at all
        if (claimedPeriod.startBlockNumber == 0 && claimedPeriod.endBlockNumber == 0) {
            claimedPeriod.startBlockNumber = startBlockNumber;
            claimedPeriod.endBlockNumber = endBlockNumber;
            return claimedPeriod;
        }
        // startB --> endB ---> claimed.startB ---> claimed.endB
        if (endBlockNumber < claimedPeriod.startBlockNumber) {
            claimedPeriod.startBlockNumber = startBlockNumber;
            return claimedPeriod;
        }

        // claimed.startB ---> claimed.endB ---> startB --> endB
        if (startBlockNumber > claimedPeriod.endBlockNumber) {
            claimedPeriod.endBlockNumber = endBlockNumber;
            return claimedPeriod;        
        }
    
        revert InvalidNewClaimPeriod();
    }

    function setVkHashes(bytes32[] calldata _vkHashes, uint16[] calldata _sizes) public onlyOwner {
        require(_vkHashes.length == _sizes.length, "length not match");
        for (uint256 i = 0; i < _vkHashes.length; i++) {
            vkHashesToCircuitSize[_vkHashes[i]] = _sizes[i];
        }

        emit VkHashesUpdated(_vkHashes, _sizes);
    }

    function setRewardToken(address _rewardToken, uint24 _decimals) external onlyOwner {
        rewardToken = _rewardToken;
        rewardTokenDecimals = _decimals;
    }

    function setAccountModule(IAccountModule _accountModule) external onlyOwner {
        accountModule = _accountModule;
    }
}
